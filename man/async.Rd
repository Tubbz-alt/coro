% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/async.R
\name{async}
\alias{async}
\alias{await}
\title{Make an async function}
\usage{
async(fn)

await(x)
}
\arguments{
\item{fn}{An anonymous function within which \code{await()} calls are
allowed.}

\item{x}{An awaitable value, i.e. a \link[promises:promise]{promise}.}
}
\value{
A function that returns a \code{\link[promises:promise]{promises::promise()}}.
}
\description{
\code{async()} functions are the building blocks of cooperative
concurrency. They suspend themselves with \code{await()} when they
expect an operation to take a long time to complete. While they
wait for the result, other async functions can be resumed once they
are ready to make progress.
}
\section{Concurrency framework}{


The default scheduler used by \code{async()} functions is provided by
the \emph{later} package. It currently only supports timers but these
are sufficient to implement basic cooperative concurrency. Since
this scheduler normally runs at top level, the async functions are
called back once all current computations have finished running.

\code{async()} functions can be chained to promises from the \emph{promises}
package.
}

\examples{
# This async function counts down from `n`, sleeping for 2 seconds
# at each iteration:
async_count_down <- async(function(n) {
  while (n > 0) {
    cat("Down", n, "\n")
    await(async_sleep(2))
    n <- n - 1
  }
})

# This async function counts up until `stop`, sleeping for 0.5
# seconds at each iteration:
async_count_up <- async(function(stop) {
  n <- 1
  while (n <= stop) {
    cat("Up", n, "\n")
    await(async_sleep(0.5))
    n <- n + 1
  }
})

# You can run these functions concurrently using `promise_all()`
if (FALSE) {
  promises::promise_all(async_count_down(5), async_count_up(5))
}
}
\seealso{
\code{\link[=async_generator]{async_generator()}} and \code{\link[=await_each]{await_each()}};
\code{\link[=flowery_debug]{flowery_debug()}} for step-debugging.
}

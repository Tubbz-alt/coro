% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step.R
\name{steps}
\alias{steps}
\alias{take_step}
\alias{map_step}
\alias{keep_step}
\alias{discard_step}
\title{Transformation steps}
\usage{
take_step(.n)

map_step(.f, ...)

keep_step(.p, ...)

discard_step(.p, ...)
}
\arguments{
\item{.n}{The number of inputs to take.}

\item{.f}{A function to map over inputs. If needed this argument is
transformed to a function with \code{\link[rlang:as_function]{rlang::as_closure()}} and thus
supports the lambda-formula notation.}

\item{...}{Further arguments passed over to \code{.f} or \code{.p}.}

\item{.p}{A predicate function applied to inputs. If needed this
argument is transformed to a function with \code{\link[rlang:as_function]{rlang::as_closure()}}
and thus supports the lambda-formula notation.}
}
\description{
Transformation steps can be chained together to modify the
behaviour of a reducer (see \code{\link[=reduce_steps]{reduce_steps()}}) or from an
iterator (see \code{iter_adapt()}).
\itemize{
\item \code{map_step()} applies a function \code{.f} over all inputs.
\item \code{discard_step()} and \code{keep_step()} apply a predicate \code{.p} over
inputs and discard or keep the selected elements.
\item \code{take_step()} is a transformation step that terminates early
after \code{.n} inputs.
}
}
\details{
Transformation steps, also called transducers, are function
operators that take a reducer function and return another reducer
function with modified behaviour. See \code{\link[=reduce_steps]{reduce_steps()}} for more
information.
}
\examples{
# `purrr::compose()` is the recommended way to chain transformation
# steps:
compose <- purrr::compose
steps <- compose(map_step(`+`, 10), discard_step(`>`, 15))
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step.R
\name{steps}
\alias{steps}
\alias{iter_take}
\alias{iter_map}
\alias{iter_keep}
\alias{iter_discard}
\title{Transformation steps}
\usage{
iter_take(n)

iter_map(.f, ...)

iter_keep(.p, ...)

iter_discard(.p, ...)
}
\arguments{
\item{n}{The number of inputs to take.}

\item{.f}{A function to map over inputs. If needed this argument is
transformed to a function with \code{\link[rlang:as_function]{rlang::as_closure()}} and thus
supports the lambda-formula notation.}

\item{...}{Further arguments passed over to \code{.f} or \code{.p}.}

\item{.p}{A predicate function applied to inputs. If needed this
argument is transformed to a function with \code{\link[rlang:as_function]{rlang::as_closure()}}
and thus supports the lambda-formula notation.}
}
\description{
Transformation steps can be chained together to modify the
behaviour of an iterator (see \code{\link[=iter_adapt]{iter_adapt()}}).
\itemize{
\item \code{iter_map()} applies a function \code{.f} over all inputs.
\item \code{iter_discard()} and \code{iter_keep()} apply a predicate \code{.p} over
inputs and discard or keep the selected elements.
\item \code{iter_take()} is a transformation step that terminates early
after \code{n} inputs.
}
}
\details{
Transformation steps, also called transducers, are function
operators that take a reducer function and return another reducer
function with modified behaviour.
}
\examples{
# `purrr::compose()` is the recommended way to chain transformation
# steps:
steps <- purrr::compose(iter_map(`+`, 10), iter_discard(`>`, 15))
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generator.R
\name{generator}
\alias{generator}
\alias{gen}
\title{Create a generator function}
\usage{
generator(fn)

gen(expr)
}
\arguments{
\item{fn}{A function of zero or one argument to be transformed into
a generator function that can \code{\link[=yield]{yield()}} and \code{return()} values.
Within a generator, \code{for} loops have \link{iterator} support.}

\item{expr}{A yielding expression.}
}
\description{
\code{generator()} creates a factory function for generators. A
generator is an \link[=iterator]{iterator function} that can pause its
execution with \code{\link[=yield]{yield()}} and resume from where it left off. Because
they manage state for you, generators are the easiest way to create
iterators. The following rules apply:
\itemize{
\item Yielded values do not terminate the generator. If you call the
generator again, the execution resumes right after the yielding
point. All local variables are preserved.
\item Returned values terminate the generator. If called again after a
\code{return()}, the generator keeps returning \code{NULL}.
}

Generators are compatible with all iterator features such as
\code{\link[=iterate]{iterate()}}, \code{\link[=iter_adapt]{iter_adapt()}}, or \code{\link[=drain]{drain()}}.
}
\section{Passing arguments to a generator}{


You can create generator functions that take one argument. The
first time the generator is called, the argument is defined in the
suspendable function. On subsequent invokations, the argument is
returned from \code{yield()}.
}

\examples{
# A generator statement creates a generator constructor:
new_gen <- generator(function() {
  yield("foo")
  yield("bar")
  "baz"
})

# The constructor creates generator functions. They are essentially
# iterators that you can call successively to obtain values from:
iter <- new_gen()
iter()
iter()

# Once a generator has returned it keeps returning `NULL`. This
# signals to its caller that new values can no longer be
# produced. The generator is exhausted:
iter()
iter()


# You can only exhaust a generator once but you can always create
# new ones from a factory:
iter <- new_gen()
iter()

# As generators are regular iterators, you can use all iterator
# tools such as iterate() which allows you to loop over all values
# with a `for` loop:
iterate(for (x in iter) cat(x, "\n"))


# flowery provides a short syntax `gen()` for creating one-off
# generator functions. It is handy to chain iterators:
numbers <- 1:10
odds <- gen(for (x in numbers) if (x \%\% 2 != 0) yield(x))
squares <- gen(for (x in odds) yield(x^2))
greetings <- gen(for (x in squares) yield(paste("Hey", x)))

# As with all iterators, you can take() elements from a generator:
take(greetings, 2)

# Or drain the remaining elements:
drain(greetings)


# You can supply arguments to generator functions. They are
# returned from `yield()`.
new_tally <- generator(function() {
  count <- 0
  while (TRUE) {
    i <- yield(count)
    count <- count + i
  }
})
tally <- new_tally()
tally(1)
tally(2)
tally(10)
}
\seealso{
\code{\link[=flowery_debug]{flowery_debug()}} for step-debugging.
}

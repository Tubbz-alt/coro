% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter-generator.R
\name{generator}
\alias{generator}
\alias{gen}
\title{Create a generator function}
\usage{
generator(body)

gen(body)
}
\arguments{
\item{body}{The function body for the generator. It can \code{\link[=yield]{yield()}}
and \code{return()} values. Within a generator, \code{for} loops have
\link{iterator} support.}
}
\description{
A generator is an \link[=iterator]{iterator function} that can pause its
execution with \code{\link[=yield]{yield()}} and resume from where it left off. Because
they manage state for you, generators are the easiest way to create
iterators.

The main difference between a regular function and a generator is
that you can \code{\link[=yield]{yield()}} values. The following rules apply:
\itemize{
\item Yielded values never terminate the iterator, even a yielded
\code{NULL}.
\item Returned values always terminate the iterator, either early or
late. Early termination is triggered when returning a normal
value like \code{return("foo")}. The iterator produces a new value and
is marked as done. On the other hand, or late (\code{return(NULL)}
doesn't produce a new value and just terminates the iterator).
}

While they give a lot of flexibility for terminating an iterator,
these rules are a bit complicated. For this reason you should
always use \code{\link[=advance]{advance()}} to check whether there is a new value and
\code{\link[=deref]{deref()}} to obtain it.
}
\examples{
# A generator statement creates an iterator function:
iter <- generator({
  yield("foo")
  yield("bar")
  "baz"
})
iter()
iter()

# As long as the generator yields, the iterator is not done:
is_done(iter)

# Once a generator has returned the iterator is done:
iter()
is_done(iter)


# Like any iterator, once a generator has exhausted its elements it
# fails with an error if you reenter it:
# iter()  # Would be an error if run

# Let's regenerate our generator. If you're going to use the same
# kind of iterators repeatedly, it often makes sense to create a
# generator factory for that purpose:
new_yielder <- function(...) {
  generator({
    values <- list(...)
    n <- length(values)
    last <- values[[n]]
    for (x in values[-n]) yield(x)
    last
  })
}
iter <- new_yielder("foo", "bar", "barbaz")

# As generators are regular iterators, you can use all iterator
# tools such as iterate() which allows you to loop over all values
# with a `for` loop:
iterate(for (x in iter) cat(x, "\\n"))

# You can also use advance() and deref() to loop manually:
iter <- new_yielder("foo", "bar", "barbaz")
while (advance(iter)) cat(deref(iter), "\\n")


# The termination condition of a generator work the way you would
# expect. You can *yield* `NULL` from a generator without
# terminating the iteration:
iter <- generator(while (TRUE) yield(NULL))
iter()
iter()
is_done(iter)

# On the other hand *returning* NULL causes late termination of the
# iterator. This means that even though the generator has been
# reentered, it has not produced a value:
iter <- generator({ yield("foo"); NULL })
advance(iter)
deref(iter)

# Here advance reenters the iterator but because of late
# termination it doesn't advance further:
advance(iter)

# This is particularly handy in loops because they return `NULL`
# when the looping is over. In the following loop, the last yielded
# value is 3L. The generator is then reentered a last time, at
# which point the loop completes and the generator returns NULL.
# This causes late termination of the iterator:
iter <- generator(for (x in 1:3) yield(x))
iterate(for (x in iter) cat("iteration", x, "\\n"))


# The generator also has a short syntax `gen()`. It is completely
# identical to the long version but is handy when chaining
# generator expressions like in Python. Note that within a
# generator you can supply iterators to `for` loops just like in
# `iterate()`. This feature and the short alias make it handy to
# chain iterators:
numbers <- 1:10
odds <- gen(for (x in numbers) if (x \%\% 2 != 0) yield(x))
squares <- gen(for (x in odds) yield(x^2))
greetings <- gen(for (x in squares) yield(paste("Hey", x)))

# As all iterators, you can take() elements from a generator:
take(greetings, 2)

# Or drain the remaining elements:
drain(greetings)
}

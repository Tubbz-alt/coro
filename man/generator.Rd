% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter-generator.R
\name{generator}
\alias{generator}
\alias{gen}
\title{Create a generator function}
\usage{
generator(fn)

gen(expr)
}
\arguments{
\item{fn}{A function of zero arguments to be transformed into a
generator function that can \code{\link[=yield]{yield()}} and \code{return()} values.
Within a generator, \code{for} loops have \link{iterator} support.}

\item{expr}{A yielding expression.}
}
\description{
A generator is an \link[=iterator]{iterator function} that can pause its
execution with \code{\link[=yield]{yield()}} and resume from where it left off. Because
they manage state for you, generators are the easiest way to create
iterators. The main difference between a regular function and a
generator is thus that you can \code{\link[=yield]{yield()}} values. The following
rules apply:
\itemize{
\item Yielded values do not terminate the generator. If you call the
generator again, the execution resumes right after the yielding
point. All local variables are preserved.
\item Returned values terminate the generator. If called again after a
\code{return()}, the generator keeps returning \code{NULL}.
}

Generators are compatible with all iterator features such as
\code{\link[=iterate]{iterate()}}, \code{\link[=iter_adapt]{iter_adapt()}}, or \code{\link[=drain]{drain()}}.
}
\examples{
# A generator statement creates an iterator function:
iter <- generator(function() {
  yield("foo")
  yield("bar")
  "baz"
})
iter()
iter()

# Once a generator has returned it keeps returning `NULL`. This
# signals to its caller that new values can no longer be
# produced. The generator is exhausted:
iter()
iter()


# You can only exhaust a generator once. Let's create a generator
# factory to make it easy to get fresh generators:
new_yielder <- function(...) {
  generator(function() {
    values <- list(...)
    n <- length(values)
    last <- values[[n]]
    for (x in values[-n]) yield(x)
    last
  })
}
iter <- new_yielder("foo", "bar", "barbaz")

# As generators are regular iterators, you can use all iterator
# tools such as iterate() which allows you to loop over all values
# with a `for` loop:
iterate(for (x in iter) cat(x, "\n"))

# You can also check for `NULL` values that signal exhaustion to
# loop manually:
iter <- new_yielder("foo", "bar", "barbaz")
while (!is.null(new <- iter())) cat(new, "\n")


# The generator also has a short syntax `gen()`. It is completely
# identical to the long version but is handy when chaining
# generator expressions like in Python. Note that within a
# generator you can supply iterators to `for` loops just like in
# `iterate()`. This feature and the short alias make it handy to
# chain iterators:
numbers <- 1:10
odds <- gen(for (x in numbers) if (x \%\% 2 != 0) yield(x))
squares <- gen(for (x in odds) yield(x^2))
greetings <- gen(for (x in squares) yield(paste("Hey", x)))


# As all iterators, you can take() elements from a generator:
take(greetings, 2)

# Or drain the remaining elements:
drain(greetings)
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter-generator.R
\name{generator}
\alias{generator}
\alias{gen}
\title{Create a generator function}
\usage{
generator(body)

gen(body)
}
\arguments{
\item{body}{The function body for the generator. It can \code{\link[=yield]{yield()}}
and \code{return()} values. Within a generator, \code{for} loops have
\link{iterator} support.}
}
\description{
A generator is an \link[=iterator]{iterator function} that can pause its
execution with \code{\link[=yield]{yield()}} and resume from where it left off. Because
they manage state for you, generators are the easiest way to create
iterators. The main difference between a regular function and a
generator is thus that you can \code{\link[=yield]{yield()}} values. The following
rules apply:
\itemize{
\item Yielded values never terminate the iterator, even a yielded
\code{NULL}.  If you call the generator or \code{\link[=advance]{advance()}} it, the
execution resumes right after the yielding point. All local
variables are preserved.
\item Returned values always terminate the iterator. Reentering the
generator after a return is an error.
}

Generators are compatible with all iterator features such as
\code{\link[=iterate]{iterate()}}, \code{\link[=iter_adapt]{iter_adapt()}}, or \code{\link[=drain]{drain()}}.
}
\examples{
# A generator statement creates an iterator function:
iter <- generator({
  yield("foo")
  yield("bar")
  "baz"
})
iter()
iter()

# As long as the generator yields, the iterator is not done:
is_done(iter)

# Once a generator has returned the iterator is done:
iter()
is_done(iter)


# Like any iterator, once a generator has exhausted its elements it
# fails with an error if you reenter it:
# iter()  # Would be an error if run

# Let's regenerate our generator. If you're going to use the same
# kind of iterators repeatedly, it often makes sense to create a
# generator factory for that purpose:
new_yielder <- function(...) {
  generator({
    values <- list(...)
    n <- length(values)
    last <- values[[n]]
    for (x in values[-n]) yield(x)
    last
  })
}
iter <- new_yielder("foo", "bar", "barbaz")

# As generators are regular iterators, you can use all iterator
# tools such as iterate() which allows you to loop over all values
# with a `for` loop:
iterate(for (x in iter) cat(x, "\\n"))

# You can also use advance() and deref() to loop manually:
iter <- new_yielder("foo", "bar", "barbaz")
while (advance(iter)) cat(deref(iter), "\\n")


# The termination condition of a generator works the way you would
# expect. You can *yield* `NULL` from a generator without
# terminating the iteration:
iter <- generator(while (TRUE) yield(NULL))
iter()
iter()
is_done(iter)

# On the other hand *returning* NULL terminates the iterator:
iter <- generator({ while (TRUE) return(NULL) })
advance(iter)

# This is particularly handy in loops because they return `NULL`
# when the looping is over. In the following loop, the last yielded
# value is 3L. The generator is then reentered a last time, at
# which point the loop completes and the generator returns NULL.
# This signals that the iterator has completed:
iter <- generator(for (x in 1:3) yield(x))
iterate(for (x in iter) cat("iteration", x, "\\n"))


# The generator also has a short syntax `gen()`. It is completely
# identical to the long version but is handy when chaining
# generator expressions like in Python. Note that within a
# generator you can supply iterators to `for` loops just like in
# `iterate()`. This feature and the short alias make it handy to
# chain iterators:
numbers <- 1:10
odds <- gen(for (x in numbers) if (x \%\% 2 != 0) yield(x))
squares <- gen(for (x in odds) yield(x^2))
greetings <- gen(for (x in squares) yield(paste("Hey", x)))

# As all iterators, you can take() elements from a generator:
take(greetings, 2)

# Or drain the remaining elements:
drain(greetings)
}

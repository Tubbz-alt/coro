% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter.R
\name{new_iterator}
\alias{new_iterator}
\title{Create a new iterator}
\usage{
new_iterator(fn)
}
\arguments{
\item{fn}{A iterable function.}
}
\description{
This wraps \code{fn} in an iterator function that supports:
\itemize{
\item \code{\link[=deref]{deref()}} to dereference the current value of the iterator.
\item \code{\link[=advance]{advance()}} to advance to the next value.
\item \code{\link[=is_done]{is_done()}} to check if the iterator is terminated
}

See \code{\link[=iter]{iter()}} for more information on iterators.
}
\section{Iterable functions}{


In order to be iterable, \code{fn()} must meet these specifications:
\itemize{
\item It should be callable without arguments. This is how the iterator
obtains the next value.
\item It should return \code{NULL} when the iterator has exhausted all
elements. If the next element is a literal \code{NULL}, return a
\link[=null_box]{boxed NULL} instead. It will be automatically unboxed.
}
}

\examples{
# An iterator is a stateful function since it must return different
# results each time it is called. A convenient way of setting up
# the state is with a factory function, i.e. a function that
# returns another function:
new_counter <- function(n) {
  force(n)
  fn <- function() {
    if (n == 0) {
      # Return NULL to finish iteration
      return(NULL)
    }

    # Update the counter each time:
    n <<- n - 1

    n
  }

  # Wrapping `fn` in an iterator enables many features
  new_iterator(fn)
}

# We can instantiate a new iterator by calling the factory:
it <- new_counter(3)
it()

# This function supports all iterator features. It can be
# dereferenced, advanced, and tested for termination:
advance(it)
deref(it)
is_done(it)

# You can also use `iterate()`
it <- new_counter(3)
iterate(for(n in it) cat(n, "to go!\\n"))
}
\seealso{
\code{\link[=as_iterator]{as_iterator()}}
}

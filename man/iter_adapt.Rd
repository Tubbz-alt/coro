% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter-adapt.R
\name{iter_adapt}
\alias{iter_adapt}
\alias{async_adapt}
\title{Adapt an iterator with transformation steps}
\usage{
iter_adapt(iter, ...)

async_adapt(iter, steps)
}
\arguments{
\item{iter}{An \link{iterator}.}

\item{steps, ...}{\link[=steps]{Transformation steps}. These dots are taken with
implicit splicing of lists and passed to \code{compose()}.}
}
\description{
\code{iter_adapt()} takes an iterator \code{iter} and a list of
\link[=steps]{Transformation steps}. It returns an iterator that returns
transformed values.
}
\examples{
# Let's create a simple iterator:
iter <- as_iterator(1:50)
iter()

# We can transform it by mapping functions over the elements:
iter <- iter_adapt(iter, iter_map(`+`, 100L))
take(iter, 5)

# Or by discarding unwanted values:
iter <- iter_adapt(iter, iter_discard(~ .x \%\% 2 == 0))
take(iter, 5)

# Note that iter_adapt() accepts several transformation at once and
# can of course adapt generators which are regular iterators:
iter <- gen(for (x in 1:10) yield(x))
iter <- iter_adapt(iter,
  iter_map(`+`, 100L),
  iter_discard(~ .x \%\% 2 == 0)
)
take(iter, 5)
}
\seealso{
\code{\link[=iterate]{iterate()}} for looping over iterator values with \code{for}
loops.
}

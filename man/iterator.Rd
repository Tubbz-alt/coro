% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iter.R
\name{iterator}
\alias{iterator}
\alias{new_iterator}
\alias{is_iterator}
\alias{deref}
\alias{advance}
\alias{is_done}
\alias{as_iterator}
\title{Iterator functions}
\usage{
new_iterator(fn)

is_iterator(x)

deref(iter)

advance(iter)

is_done(iter)

as_iterator(x)
}
\arguments{
\item{fn}{An iterable function. It should be callable without
arguments and return \code{NULL} when the iterator is exhausted.}

\item{x}{For \code{is_iterator()}, an object to test. For
\code{as_iterator()}, a vector, iterator, or iterable function. S3
objects with \code{length()} and position-based \code{[[} methods are also
supported.}

\item{iter}{An iterator function.}
}
\description{
R programming is usually about full lists and vectors. Vectorised
operations such as \code{+} or function mappers like \code{lapply()} operate
on whole collections of elements. However these idioms do not work
so well when the data does not fit in memory. In this case vector
idioms must be replaced with chunk ones. Iterators are a convenient
way of structuring the generation of chunks of data. Iterators can
easily be \link[=iter_adapt]{transformed}, \link[=steps]{mapped over}, or
\link[=drain]{drained} to a final output vector.

Formally, an iterator is a function that returns a new value each
time it is called and that supports:
\itemize{
\item \code{deref()} to dereference the current value of the iterator.
\item \code{is_done()} to check if the iterator has exhausted its
elements. Calling an exhausted iterator causes an error of class
\code{exhausted_iter}.
\item \code{advance()} to advance to the next value. This is similar to
calling the iterator for a new element but returns \code{TRUE} if the
iterator indeed had another element or \code{FALSE} if the iterator
was exhausted. The element can then be retrieved with \code{deref()}.
}
}
\section{Early and late termination}{


The main purpose of \code{advance()} and \code{deref()} is to support two
kinds of iterators: those that terminate early and those that
terminate late.
\itemize{
\item When an iterator has been called for a new value and notices that
it is about to return the very last value, it can terminate
early. That is, it returns the last value and signals itself
done. Reentering the iterator from that point on is an error.
\item Late termination occurs when the iterator does not know in
advance whether there are remaining elements. This could happen
for instance when iterating over a stream of data. In this case,
the iterator will have to be reentered before it can discover it
is actually done and signal that iteration is terminated.
}

This is why you need to use \code{advance()} to check whether there was
a new value. It returns \code{TRUE} if it could indeed obtain a new
value and \code{FALSE} if there were no remaining elements. You can then
use \code{deref()} to obtain the last value of the iterator.
}

\section{Creating iterators}{


There are three ways of creating an iterator:
\itemize{
\item \code{\link[=generator]{generator()}} is the recommended way of creating an iterator. It
creates a generator function that can pause itself and yield a
value. When it is called again it resumes from where it left
off. Generators are a convenient way of creating iterators
because they keep their state.
\item \code{new_iterator()} takes an iterable function (see section below)
and wraps it in a proper iterator that can be dereferenced and
advanced.
\item \code{as_iterator()} also supports vectors. It creates an iterator
that iterates over the elements. If passed a regular function, it
is equivalent to \code{new_iterator()}. If passed an iterator, it is a
no-op. \code{as_iterator()} is convenient for creating functions that
support both iterators and vectors.

Vector-like objects are also supported if the class implements
\code{length()} and \code{[[} methods. The extraction method must support
positions.
}
}

\section{Iterable functions}{


Technically, iterators are thin wrappers around iterable functions
which do the actual work of generating data. While in most cases
\code{\link[=generator]{generator()}} is sufficient to create iterators, it is also
possible to create iterators with normal (but iterable) functions
that you pass to \code{new_iterator()}. In order to be iterable, a
function must meet these requirements:
\itemize{
\item It should be callable without arguments. This is how the iterator
obtains the next value.
\item It should signal termination in one of two ways: either by
returning \code{NULL} for late termination or by returning a value in
a \link[=done_box]{done box} for normal termination.
}

Late termination is useful when you don't know in advance what the
last value is. It allows reentry even if the iterator might have
exhausted all elements. Returning \code{NULL} signals that there was no
new elements after all and causes \code{advance()} to return
\code{FALSE}. This is the reason why you should always loop over an
iterator using \code{advance()} as it will check for both early and late
termination.

If the next element is a literal \code{NULL}, you can return a \link[=null_box]{boxed
NULL}. It will be automatically unboxed and won't cause
the iterator to terminate.
}

\examples{
# An iterator is a stateful function since it must return different
# results each time it is called. A convenient way of setting up
# the state is with a factory function, i.e. a function that
# returns another function:
new_counter <- function(n) {
  force(n)
  fn <- function() {
    if (n == 0) {
      # Return NULL to finish iteration
      return(NULL)
    }

    # Update the counter each time:
    n <<- n - 1

    n
  }

  # Wrapping `fn` in an iterator enables many features
  new_iterator(fn)
}

# We can instantiate a new iterator by calling the factory:
iter <- new_counter(3)
iter()

# This function supports all iterator features. It can be
# dereferenced, advanced, and tested for termination:
advance(iter)
deref(iter)
is_done(iter)

# A tricky aspect of iterators is that they can return early or
# late. Always use `advance()` when looping over an iterator. It
# returns TRUE or FALSE depending on whether there was actually a
# new element. You then use `deref()` to obtain this element:
iter <- new_counter(3)
while (advance(iter)) {
  cat(deref(iter), "to go!\\n")
}

# It is often easier to loop over an iterator with `iterate()`. It
# instruments `for` and makes it handle iterators:
iter <- new_counter(3)
iterate(for(n in iter) cat(n, "to go!\\n"))


# It is much easier to create iterators with generators:
new_counter <- function(n) {
  force(n)
  generator({
    while (n > 0) {
      n <- n - 1
      yield(n)
    }
  })
}

# This generator behaves exactly as our other iterator function:
iter <- new_counter(3)
iterate(for(n in iter) cat(n, "to go!\\n"))
}
\seealso{
\code{\link[=generator]{generator()}} is the recommended way of creating iterators.
}
